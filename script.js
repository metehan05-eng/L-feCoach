/**
 * LifeCoach AI - Frontend Logic
 * Author: HAN AI Technology (Generated by AI)
 * Version: 1.0.0
 *
 * This script handles all frontend interactivity, chat logic,
 * and mock backend/Supabase connections.
 */
document.addEventListener('DOMContentLoaded', () => {

    // --- 1. CONFIGURATION & STATE ---
    const config = {
        BACKEND_URL: 'http://localhost:8000',
        INACTIVITY_TIMEOUT: 120000 // 2 minutes
    };

    let state = {
        token: localStorage.getItem('token'),
        isSidebarCollapsed: false,
        inactivityTimer: null,
        currentFeature: 'chat', // default
        userData: null, // Will store user type, message count, etc.
        isLimitReached: false,
        cooldownEndTime: null,
    };

    // --- 2. DOM ELEMENT SELECTORS ---
    const dom = {
        appContainer: document.getElementById('app-container'),
        sidebar: document.getElementById('sidebar'),
        sidebarToggle: document.getElementById('sidebar-toggle'),
        messageList: document.getElementById('message-list'),
        userInput: document.getElementById('user-input'),
        sendButton: document.getElementById('send-button'),
        authButtons: document.getElementById('auth-buttons'),
        comingSoonModal: document.getElementById('coming-soon-modal'),
        authModal: document.getElementById('auth-modal'),
        navLinks: document.querySelectorAll('.nav-link'),
        chatHeader: document.querySelector('.chat-header'),
        messageCounter: document.getElementById('message-counter'),
        // Feature sections
        chatSection: document.getElementById('chat-section'),
        journalSection: document.getElementById('journal-section'),
        goalSection: document.getElementById('goal-section'),
        settingsSection: document.getElementById('settings-section'),
        // Journal elements
        journalEntries: document.getElementById('journal-entries'),
        newJournalBtn: document.getElementById('new-journal-btn'),
        // Goal elements
        goalList: document.getElementById('goal-list'),
        newGoalBtn: document.getElementById('new-goal-btn'),
        // Settings elements
        settingsForm: document.getElementById('settings-form'),
        settingsLanguage: document.getElementById('settings-language'),
        settingsNotifications: document.getElementById('settings-notifications'),
    };

    // --- 3. CORE FUNCTIONS ---

    let isSigningUp = false;

    /**
     * Shows auth error message.
     * @param {string} msg - Error message.
     */
    const showAuthError = (msg) => {
        const errorDiv = dom.authModal.querySelector('#auth-error');
        errorDiv.textContent = msg;
        errorDiv.style.display = 'block';
    };

    /**
     * Loads user data including message count and premium status.
     */
    const loadUserData = () => {
        if (!state.token) return;
        fetch(`${config.BACKEND_URL}/auth/me`, {
            headers: { Authorization: `Bearer ${state.token}` }
        })
        .then(res => res.json())
        .then(userData => {
            state.userData = userData;
            updateAuthUI();
        })
        .catch(err => {
            console.error('User data load error', err);
        });
    };

    /**
     * Updates the message counter display for free users.
     */
    const updateMessageCounter = () => {
        if (!state.userData || state.userData.user_type === 'premium') {
            dom.messageCounter.style.display = 'none';
            return;
        }

        const remaining = Math.max(0, 10 - (state.userData.message_count || 0));
        dom.messageCounter.style.display = 'block';
        dom.messageCounter.innerHTML = `
            <div class="message-limit-info">
                <span>ğŸ“ Kalan mesaj hakkÄ±: ${remaining}/10</span>
            </div>
        `;
    };

    /**
     * Checks if user is in cooldown period.
     */
    const checkCooldownStatus = () => {
        if (!state.userData || state.userData.user_type === 'premium') {
            state.isLimitReached = false;
            state.cooldownEndTime = null;
            return;
        }

        const messageCount = state.userData.message_count || 0;
        if (messageCount >= 10) {
            // Check if cooldown period has passed (5 hours)
            const lastMessageDate = state.userData.last_message_date;
            if (lastMessageDate) {
                const lastMessageTime = new Date(lastMessageDate + 'Z').getTime();
                const currentTime = new Date().getTime();
                const cooldownPeriod = 5 * 60 * 60 * 1000; // 5 hours in milliseconds

                if (currentTime - lastMessageTime < cooldownPeriod) {
                    state.isLimitReached = true;
                    state.cooldownEndTime = lastMessageTime + cooldownPeriod;
                    showLimitReachedCard();
                } else {
                    // Cooldown period passed, reset message count
                    state.isLimitReached = false;
                    state.cooldownEndTime = null;
                    // Reset would happen on next message, but for now just allow
                }
            } else {
                state.isLimitReached = true;
                showLimitReachedCard();
            }
        } else {
            state.isLimitReached = false;
            state.cooldownEndTime = null;
        }
    };

    /**
     * Shows the limit reached card.
     */
    const showLimitReachedCard = () => {
        const existingCard = document.getElementById('limit-reached-card');
        if (existingCard) return;

        const card = document.createElement('div');
        card.id = 'limit-reached-card';
        card.className = 'limit-reached-card';
        card.innerHTML = `
            <div class="limit-card-content">
                <h3>â° KonuÅŸma sÃ¼resi doldu</h3>
                <p>GÃ¼nlÃ¼k 10 mesaj hakkÄ±nÄ±zÄ± kullandÄ±nÄ±z. SÄ±nÄ±rsÄ±z konuÅŸma iÃ§in Premium'a geÃ§in!</p>
                <div class="cooldown-timer">
                    <span id="cooldown-display">5 saat sonra aktifleÅŸir</span>
                </div>
                <button id="upgrade-premium-btn" class="btn btn-primary">Premium'a GeÃ§</button>
            </div>
        `;

        dom.messageList.appendChild(card);
        dom.messageList.scrollTop = dom.messageList.scrollHeight;

        // Add event listener for premium button
        document.getElementById('upgrade-premium-btn').addEventListener('click', () => {
            window.location.href = '/premium.html';
        });

        // Start cooldown timer
        updateCooldownTimer();
    };

    /**
     * Updates the cooldown timer display.
     */
    const updateCooldownTimer = () => {
        const display = document.getElementById('cooldown-display');
        if (!display || !state.cooldownEndTime) return;

        const updateTimer = () => {
            const now = new Date().getTime();
            const timeLeft = state.cooldownEndTime - now;

            if (timeLeft <= 0) {
                display.textContent = 'Åimdi aktif!';
                state.isLimitReached = false;
                const card = document.getElementById('limit-reached-card');
                if (card) card.remove();
                return;
            }

            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            display.textContent = `${hours} saat ${minutes} dakika sonra aktifleÅŸir`;

            setTimeout(updateTimer, 60000); // Update every minute
        };

        updateTimer();
    };

    /**
     * Loads chat history for logged in user.
     */
    const loadChatHistory = () => {
        if (!state.token) return;
        // Removed history loading, just show greeting
        appendMessage('Merhaba! BugÃ¼n sana nasÄ±l yardÄ±mcÄ± olabilirim?', 'ai');
    };

    /**
     * Appends a message to the chat interface instantly (for history loading).
     * @param {string} text - The message content.
     * @param {('ai'|'user')} sender - The sender of the message.
     */
    const appendMessageInstant = (text, sender) => {
        const bubble = document.createElement('div');
        bubble.classList.add('message-bubble', `${sender}-message`);
        bubble.textContent = text;

        dom.messageList.appendChild(bubble);
        dom.messageList.scrollTop = dom.messageList.scrollHeight;
        return bubble;
    };

    /**
     * Appends a message to the chat interface instantly.
     * @param {string} text - The message content.
     * @param {('ai'|'user')} sender - The sender of the message.
     */
    const appendMessage = (text, sender) => {
        const bubble = document.createElement('div');
        bubble.classList.add('message-bubble', `${sender}-message`);
        bubble.textContent = text;

        dom.messageList.appendChild(bubble);
        dom.messageList.scrollTop = dom.messageList.scrollHeight;
        resetInactivityTimer();
        return bubble;
    };

    /**
     * Shows a small toast notification at the bottom-right.
     * @param {string} msg
     * @param {number} duration
     */
    const showToast = (msg, duration = 4000) => {
        let container = document.getElementById('toast-container');
        if (!container) {
            container = document.createElement('div');
            container.id = 'toast-container';
            container.style.position = 'fixed';
            container.style.right = '18px';
            container.style.bottom = '18px';
            container.style.zIndex = 9999;
            document.body.appendChild(container);
        }
        const t = document.createElement('div');
        t.className = 'toast';
        t.textContent = msg;
        t.style.background = 'rgba(0,0,0,0.85)';
        t.style.color = '#fff';
        t.style.padding = '8px 12px';
        t.style.marginTop = '8px';
        t.style.borderRadius = '6px';
        t.style.boxShadow = '0 4px 12px rgba(0,0,0,0.2)';
        t.style.fontSize = '0.9rem';
        t.style.opacity = '0';
        t.style.transition = 'opacity 240ms ease-in-out';
        container.appendChild(t);
        requestAnimationFrame(() => { t.style.opacity = '1'; });
        setTimeout(() => {
            t.style.opacity = '0';
            setTimeout(() => t.remove(), 300);
        }, duration);
    };

    /**
     * Handles sending the user's message.
     */
    const handleSendMessage = async () => {
        if (!state.token) {
            setupAuthModal(false);
            showModal(dom.authModal);
            return;
        }

        const messageText = dom.userInput.value.trim();
        if (!messageText) return;

        appendMessage(messageText, 'user');
        dom.userInput.value = '';
        dom.userInput.disabled = true;

        // --- Backend call ---
        try {
            const endpoint = `${config.BACKEND_URL.replace(/\/$/, '')}/chat`;
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    Authorization: `Bearer ${state.token}`
                },
                body: JSON.stringify({ message: messageText, feature: state.currentFeature })
            });

            const data = await response.json();
            if (response.ok) {
                const aiPayload = data.response;
                let aiText = '';
                let aiSource = null;
                let aiModel = null;
                if (typeof aiPayload === 'string') {
                    aiText = aiPayload;
                } else if (aiPayload && aiPayload.text) {
                    aiText = aiPayload.text;
                    aiSource = aiPayload.source;
                    aiModel = aiPayload.model;
                } else {
                    aiText = 'AnladÄ±m.';
                }
                const bubble = appendMessage(aiText, 'ai');
                if (aiSource) {
                    const badge = document.createElement('div');
                    badge.className = 'message-source';
                    badge.textContent = `Kaynak: ${aiSource}${aiModel ? ' (' + aiModel + ')' : ''}`;
                    badge.style.fontSize = '0.8rem';
                    badge.style.opacity = '0.8';
                    badge.style.marginTop = '6px';
                    bubble.appendChild(badge);
                }
            } else {
                const errorMsg = data.detail || data.response || 'Bir hata oluÅŸtu. LÃ¼tfen tekrar deneyin.';
                appendMessage(errorMsg, 'ai');
            }
        } catch (error) {
            console.warn('Backend eriÅŸilemedi', error);
            appendMessage('BaÄŸlantÄ± hatasÄ±. LÃ¼tfen tekrar deneyin.', 'ai');
        } finally {
            dom.userInput.disabled = false;
            dom.userInput.focus();
        }
    };
    
    /**
     * Toggles the sidebar visibility.
     */
    const toggleSidebar = () => {
        state.isSidebarCollapsed = !state.isSidebarCollapsed;
        dom.appContainer.classList.toggle('sidebar-collapsed', state.isSidebarCollapsed);
    };

    /**
     * Shows a modal by its ID.
     * @param {HTMLElement} modalElement - The modal element to show.
     */
    const showModal = (modalElement) => {
        modalElement.style.display = 'flex';
        setTimeout(() => modalElement.classList.add('active'), 10);
    };

    /**
     * Hides an active modal.
     * @param {HTMLElement} modalElement - The modal element to hide.
     */
    const hideModal = (modalElement) => {
        modalElement.classList.remove('active');
        setTimeout(() => modalElement.style.display = 'none', 300);
    };

    /**
     * Updates the UI based on authentication status.
     */
    const updateAuthUI = () => {
        state.token = localStorage.getItem('token');
        dom.authButtons.innerHTML = ''; // Clear existing buttons

        if (state.token) {
            const logoutBtn = document.createElement('button');
            logoutBtn.className = 'btn btn-secondary';
            logoutBtn.textContent = 'Ã‡Ä±kÄ±ÅŸ Yap';
            logoutBtn.onclick = () => {
                localStorage.removeItem('token');
                state.token = null;
                updateAuthUI();
                // Clear chat
                dom.messageList.innerHTML = '';
            };

            dom.authButtons.appendChild(logoutBtn);
        } else {
            const loginBtn = document.createElement('button');
            loginBtn.className = 'btn btn-secondary';
            loginBtn.textContent = 'GiriÅŸ Yap';
            loginBtn.onclick = () => {
                setupAuthModal(false);
                showModal(dom.authModal);
            };

            dom.authButtons.appendChild(loginBtn);
        }
    };

    /**
     * Configures and shows the authentication modal.
     * @param {boolean} isSigningUpParam - True for signup, false for login.
     */
    const setupAuthModal = (isSigningUpParam) => {
        isSigningUp = isSigningUpParam;
        const title = dom.authModal.querySelector('#auth-title');
        const submitBtn = dom.authModal.querySelector('#auth-submit-btn');
        const prompt = dom.authModal.querySelector('#auth-toggle-prompt');
        const link = dom.authModal.querySelector('#auth-toggle-link');
        const errorDiv = dom.authModal.querySelector('#auth-error');
        errorDiv.style.display = 'none';

        if (isSigningUp) {
            title.textContent = 'Ãœye Ol';
            submitBtn.textContent = 'Hesap OluÅŸtur';
            prompt.textContent = 'HesabÄ±n var mÄ±?';
            link.textContent = 'GiriÅŸ Yap';
            link.onclick = (e) => { e.preventDefault(); setupAuthModal(false); };
        } else {
            title.textContent = 'GiriÅŸ Yap';
            submitBtn.textContent = 'GiriÅŸ Yap';
            prompt.textContent = 'HesabÄ±n yok mu?';
            link.textContent = 'Ãœye Ol';
            link.onclick = (e) => { e.preventDefault(); setupAuthModal(true); };
        }
    };

    /**
     * Loads journal entries from the backend.
     */
    const loadJournalEntries = () => {
        if (!state.token) return;
        dom.journalEntries.innerHTML = '<p>GÃ¼nlÃ¼k giriÅŸleriniz yÃ¼kleniyor...</p>';

        fetch(`${config.BACKEND_URL}/journal/entries`, {
            headers: { Authorization: `Bearer ${state.token}` }
        })
        .then(res => res.json())
        .then(entries => {
            if (entries.length === 0) {
                dom.journalEntries.innerHTML = '<p>HenÃ¼z gÃ¼nlÃ¼k giriÅŸi yapmadÄ±nÄ±z. Yeni bir giriÅŸ oluÅŸturmak iÃ§in yukarÄ±daki butona tÄ±klayÄ±n.</p>';
            } else {
                dom.journalEntries.innerHTML = entries.map(entry => `
                    <div class="journal-entry">
                        <h3>${entry.title}</h3>
                        <p>${entry.content}</p>
                        <small>${new Date(entry.created_at).toLocaleDateString('tr-TR')}</small>
                    </div>
                `).join('');
            }
        })
        .catch(err => {
            console.error('Journal load error', err);
            dom.journalEntries.innerHTML = '<p>GÃ¼nlÃ¼k giriÅŸleri yÃ¼klenirken hata oluÅŸtu.</p>';
        });
    };

    /**
     * Loads goals from the backend.
     */
    const loadGoals = () => {
        if (!state.token) return;
        dom.goalList.innerHTML = '<p>Hedefleriniz yÃ¼kleniyor...</p>';

        fetch(`${config.BACKEND_URL}/goals`, {
            headers: { Authorization: `Bearer ${state.token}` }
        })
        .then(res => res.json())
        .then(goals => {
            if (goals.length === 0) {
                dom.goalList.innerHTML = '<p>HenÃ¼z hedef belirlemediniz. Yeni bir hedef oluÅŸturmak iÃ§in yukarÄ±daki butona tÄ±klayÄ±n.</p>';
            } else {
                dom.goalList.innerHTML = goals.map(goal => `
                    <div class="goal-item">
                        <h3>${goal.title}</h3>
                        <p>${goal.description}</p>
                        <div class="progress-bar">
                            <div class="progress-fill" style="width: ${goal.progress}%"></div>
                        </div>
                        <small>%${goal.progress} TamamlandÄ±</small>
                    </div>
                `).join('');
            }
        })
        .catch(err => {
            console.error('Goals load error', err);
            dom.goalList.innerHTML = '<p>Hedefler yÃ¼klenirken hata oluÅŸtu.</p>';
        });
    };

    /**
     * Loads user settings.
     */
    const loadSettings = () => {
        if (!state.token) return;
        // TODO: Replace with actual API call
        // Mock settings
        dom.settingsLanguage.value = 'tr';
        dom.settingsNotifications.checked = true;
    };

    /**
     * Handles the initial greeting sequence.
     */
    const runGreetingSequence = () => {
        setTimeout(() => {
            appendMessage('ğŸ‘‹ Merhaba, bugÃ¼n sana nasÄ±l yardÄ±mcÄ± olabilirim?', 'ai');
        }, 1000);
    };
    
    /**
     * Switches to a different feature section.
     * @param {string} feature - The feature to switch to.
     */
    const switchFeature = (feature) => {
        // Hide all sections
        [dom.chatSection, dom.journalSection, dom.goalSection, dom.settingsSection].forEach(section => {
            section.classList.remove('active');
        });

        // Show the selected section
        const sectionMap = {
            'chat': dom.chatSection,
            'journal': dom.journalSection,
            'goal-tracking': dom.goalSection,
            'settings': dom.settingsSection,
            'deep-conversation': null, // Handled by premium modal
            'life-plan': null // Handled by premium modal
        };

        const targetSection = sectionMap[feature];
        if (targetSection) {
            targetSection.classList.add('active');
            state.currentFeature = feature;

            // Load feature-specific data
            switch (feature) {
                case 'chat':
                    // Chat is already loaded
                    break;
                case 'journal':
                    loadJournalEntries();
                    break;
                case 'goal-tracking':
                    loadGoals();
                    break;
                case 'settings':
                    loadSettings();
                    break;
            }
        }
    };

    /**
     * Resets the inactivity timer.
     */
    const resetInactivityTimer = () => {
        clearTimeout(state.inactivityTimer);
        state.inactivityTimer = setTimeout(() => {
            if (state.currentFeature === 'chat') {
                appendMessage("Bir sÃ¼redir sessizsin. Dilersen, Ã¼zerinde dÃ¼ÅŸÃ¼ndÃ¼ÄŸÃ¼n bir konuyu derinlemesine ele alabiliriz.", "ai");
            }
        }, config.INACTIVITY_TIMEOUT);
    };

    /**
     * Enable mouse-follow scrolling inside the chat message list.
     * When the user moves the mouse over the chat area, the scroll
     * position moves proportionally to the vertical cursor position.
     */
    const enableMouseFollowScroll = (el) => {
        if (!el) return;
        let isPointerOver = false;
        el.style.cursor = 'default';

        el.addEventListener('mouseenter', () => { isPointerOver = true; });
        el.addEventListener('mouseleave', () => { isPointerOver = false; });

        el.addEventListener('mousemove', (e) => {
            if (!isPointerOver) return;
            // Calculate mouse Y relative to the element
            const rect = el.getBoundingClientRect();
            const y = e.clientY - rect.top; // 0 .. rect.height
            const ratio = Math.max(0, Math.min(1, y / rect.height));
            const maxScroll = el.scrollHeight - el.clientHeight;
            // Smoothly set scrollTop proportional to the ratio
            el.scrollTop = Math.round(ratio * maxScroll);
        });

        // Also allow wheel and touch as usual
        el.addEventListener('wheel', (e) => { /* default behavior */ }, { passive: true });
    };


    // --- 4. EVENT LISTENERS ---

    // Quick option buttons
    document.addEventListener('click', (e) => {
        if (e.target.classList.contains('quick-btn')) {
            const prompt = e.target.dataset.prompt;
            dom.userInput.value = prompt;
            handleSendMessage();
        }
    });

    // Send message
    dom.sendButton.addEventListener('click', handleSendMessage);
    dom.userInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            handleSendMessage();
        }
    });

    // Sidebar toggle
    dom.sidebarToggle.addEventListener('click', toggleSidebar);

    // Modal closing
    [dom.comingSoonModal, dom.authModal].forEach(modal => {
        modal.addEventListener('click', (e) => {
            if (e.target === modal || e.target.classList.contains('modal-close-btn')) {
                hideModal(modal);
            }
        });
    });

    // Nav link clicks
    dom.navLinks.forEach(link => {
        link.addEventListener('click', (e) => {
            e.preventDefault();
            const feature = link.dataset.feature;
            if (feature === 'chat' || feature === 'settings') {
                // Set active nav link
                dom.navLinks.forEach(l => l.classList.remove('active'));
                link.classList.add('active');
                // Switch to the feature
                switchFeature(feature);
            } else {
                // Coming soon
                const featureNames = {
                    'journal': 'AI GÃ¼nlÃ¼k',
                    'goal-tracking': 'Hedef Takibi',
                    'deep-conversation': 'Derin Sohbet',
                    'life-plan': 'Hayat PlanÄ±'
                };
                const name = featureNames[feature] || feature;
                const messageEl = dom.comingSoonModal.querySelector('#coming-soon-message');
                messageEl.textContent = `${name} Ã§ok yakÄ±nda gelecek.`;
                showModal(dom.comingSoonModal);
            }
        });
    });

    // Journal new entry button
    dom.newJournalBtn.addEventListener('click', () => {
        // TODO: Open journal entry modal/form
        showToast('Yeni gÃ¼nlÃ¼k giriÅŸi Ã¶zelliÄŸi yakÄ±nda gelecek!', 3000);
    });

    // Goal new goal button
    dom.newGoalBtn.addEventListener('click', () => {
        // TODO: Open new goal modal/form
        showToast('Yeni hedef ekleme Ã¶zelliÄŸi yakÄ±nda gelecek!', 3000);
    });

    // Settings form submission
    dom.settingsForm.addEventListener('submit', (e) => {
        e.preventDefault();
        // TODO: Save settings to backend
        const language = dom.settingsLanguage.value;
        const notifications = dom.settingsNotifications.checked;
        showToast('Ayarlar kaydedildi!', 3000);
    });

    // Auth form submission
    dom.authModal.querySelector('#auth-form').addEventListener('submit', async (e) => {
        e.preventDefault();
        const email = dom.authModal.querySelector('#auth-email').value.trim();
        const password = dom.authModal.querySelector('#auth-password').value.trim();
        if (!email || !password) return;

        const endpoint = isSigningUp ? `${config.BACKEND_URL}/auth/register` : `${config.BACKEND_URL}/auth/login`;
        try {
            const response = await fetch(endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ email, password })
            });
            const data = await response.json();
            if (response.ok && data.access_token) {
                // Save token and update UI
                localStorage.setItem('token', data.access_token);
                state.token = data.access_token;
                updateAuthUI();
                hideModal(dom.authModal);
                loadUserData();
                loadChatHistory();

                // Debug: print token and show a short confirmation toast
                try {
                    console.log('Access token:', data.access_token);
                    showToast('GiriÅŸ baÅŸarÄ±lÄ± â€” token konsola yazÄ±ldÄ± ve kaydedildi.', 4500);
                } catch (e) {
                    console.warn('Token debug failed', e);
                }
            } else {
                showAuthError(data.detail || 'Hata oluÅŸtu');
            }
        } catch (err) {
            showAuthError('BaÄŸlantÄ± hatasÄ±');
        }
    });
    
    // Mobile menu toggle
    const mobileMenuBtn = document.createElement('button');
    mobileMenuBtn.className = 'mobile-menu-btn';
    mobileMenuBtn.innerHTML = '<svg viewBox="0 0 24 24"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></svg>';
    mobileMenuBtn.style.display = 'none'; // Initially hidden
    dom.chatHeader.prepend(mobileMenuBtn);

    const handleResize = () => {
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
            if (!state.isSidebarCollapsed) toggleSidebar();
            mobileMenuBtn.style.display = 'block';
        } else {
            mobileMenuBtn.style.display = 'none';
        }
    };
    mobileMenuBtn.addEventListener('click', () => {
        dom.appContainer.classList.add('sidebar-open');
        const overlay = document.createElement('div');
        overlay.className = 'mobile-sidebar-overlay';
        document.body.appendChild(overlay);
        overlay.addEventListener('click', () => {
             dom.appContainer.classList.remove('sidebar-open');
             overlay.remove();
        });
    });


    // --- 5. INITIALIZATION ---
    const init = () => {
        console.log('LifeCoach AI Initializing...');
        updateAuthUI();
        if (state.token) {
            loadUserData();
            loadChatHistory();
        } else {
            setupAuthModal(false);
            showModal(dom.authModal);
        }
        // Enable mouse-follow scrolling for the chat area
        enableMouseFollowScroll(dom.messageList);

        resetInactivityTimer();
        window.addEventListener('resize', handleResize);
        handleResize(); // Initial check
        dom.userInput.focus();
    };

    try {
        init();
    } catch (error) {
        console.error('Fatal error during initialization:', error);
        console.error('Stack:', error.stack);
    }
});
